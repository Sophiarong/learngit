 第一版
=
    
    #include<stdio.h>

    typedef struct        //集合结构体的类型 
    {   
      int data[];       //存放集合中的元素
	  int length;       //存放集合中实际元素的个数 
    }Set;               //新类型名Set 

    void build(Set &A, int a[], int n) //创建一个集合 
    {
	  int i;
	  for(i=0;i<n;i++)
	  {
	     A.data[i]=a[i];
	     printf("%d\n",A.data[i]);  //如果我直接在这里打印的话它就乖乖显示12345678910
	  }
      A.length=n;
    }

    void pri(Set &A)
    {
	  int i;
	  for(i=0;i<A.length;i++)
	  printf("%d\n",A.data[i]);    //老是出现102345678910，是不是犯了什么低级错误啊
    }

    int main(void)
    {
	  int a[]={1,2,3,4,5,6,7,8,9,10},n=10;
	  Set A;
	  build(A, a, n);
	  pri(A);
	  return 0;
    } 

----------

#第二版

    typedef struct        
    {   int data[100]; //这里经过了修正，而且放9居然也可以  
	    int length;       
    }Set;                  

    void build(Set &A, int a[], int n) //创建一个集合 
    {
	    int i;
	    for(i=0;i<n;i++)
	    {
	       A.data[i]=a[i];
	    }
        A.length=n;
    }

    void pri(Set &A)
    {
	  int i;
	  for(i=0;i<A.length;i++)
	  {printf("%d\n",A.data[i]);}
    }

    bool judgement(Set &A, int e)
    {
	  int i;
	  for(i=0;i<A.length;i++)
	     if(A.data[i]==e)
         {
        	return true;
         }
      return false;                  //记得false一定要放在这里啊，因为一旦return就退出这个函数了
    }

    int main(void)
    {
	  int a[]={1,2,3,4,5,6,7,8,9,10},n=10,e;
	  Set A;
	  printf("Input");
	  scanf("%d",&e);
	  build(A, a, n);
	  pri(A);
      if(judgement(A,e))
      printf("YES");
      else
      printf("No");
	  return 0;
    } 

----------
第三版
=
    #include<stdio.h>
    
    typedef struct//集合结构体的类型 
    {   int data[100];  
    	int length;   
    }Set; //新类型名Set 
    
    void build(Set &A, int a[], int n) //创建一个集合 
    {
    	int i;
    	for(i=0;i<n;i++)
    	  {
    	   A.data[i]=a[i];
    	  }
    A.length=n;
    }
    
    void pri(Set &A)//输出集合
    {
    	int i;
    	for(i=0;i<A.length;i++)
    	printf("%d ",A.data[i]);
    	printf("\n"); 
    }
    
    bool judgement(Set &A, int e)//判断是否属于集合
    {
    	int i;
    	for(i=0;i<A.length;i++)
    	  if(A.data[i]==e)
    {
    	return true;
    }
    return false;
    }
    
    void add(Set &A1,Set &A2,Set &A3)//求并集
    {
    	int i;
    	for(i=0;i<A1.length;i++)
    	  A3.data[i]=A1.data[i];
    	  A3.length=A1.length;
        for(i=0;i<A2.length;i++)
        if(!judgement(A1,A2.data[i]))
        {
      	  A3.data[A3.length]=A2.data[i];
      	  A3.length++;
        }
     }
    
    void minus(Set &A1,Set &A2,Set &A3)//求差集
    {
    	int i;
    	A3.length=0;
    	for(i=0;i<A1.length;i++)
    	  if(!judgement(A2,A1.data[i]))
    	  {
      		A3.data[i]=A1.data[i];
      		A3.length++;
      	  }
    }
    
    void intersection(Set &A1,Set &A2,Set &A3)//求交集
    {
     int i;
    	 A3.length=0;
    	 for(i=0;i<A1.length;i++)
     if(judgement(A2,A1.data[i]))
    	  {
      		A3.data[A3.length]=A1.data[i];//方括号里的一定要是A3.length，不能是i，否则将出错
      		A3.length++;
      	  }
    }
    
    int main(void)
    {
    	int a[]={1,2,3,4,5,6,7,8,9,10},n=10;
    	int b[]={4,5,6,7,8,9,10,11,12,13};
    	Set A1,A2,A3;
    	build(A1, a, n);
    	pri(A1);
    	build(A2, b, n);
    	pri(A2);
    	intersection(A1 ,A2 ,A3);//这里要么add,要么minus,intersection，不能忘了呀，不然会乱码
    	pri(A3);
    	return 0; 
    } 